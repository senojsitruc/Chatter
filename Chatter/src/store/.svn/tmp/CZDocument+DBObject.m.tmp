//
//  CZDocument.m
//  ScriptSync
//
//  Created by Curtis Jones on 2010.09.17.
//  Copyright 2010 Nexidia, Inc. All rights reserved.
//

#import "CZDocument+DBObject.h"
#import "CZGroup+DBObject.h"
#import "CZScript+DBObject.h"
#import "DBConnection.h"
#import "SQLiteDBConnection.h"

@implementation CZDocument (DBObject)

#pragma mark -
#pragma mark Database Management

/**
 * Copies the default database from the application bundle to the document bundle if it doesn't
 * already exist. This fails if the document bundle directory doesn't exist, as well.
 *
 */
- (BOOL)createDatabase
{
	BOOL isDir;
	NSString *dbdst, *dbsrc;
	NSError *error;
	NSFileManager *fileManager = [[[NSFileManager alloc] init] autorelease];
	
	// fail if the path for this document is nil or zero-length
	if (0 == [mPath length]) {
		NSLog(@"%s.. no document path specified.", __PRETTY_FUNCTION__);
		return FALSE;
	}
	
	// fail if the document directory does not exist
	if (FALSE == [fileManager fileExistsAtPath:mPath isDirectory:&isDir]) {
		NSLog(@"%s.. document bundle does not exist at '%@'", __PRETTY_FUNCTION__, mPath);
		return FALSE;
	}
	// or if it happens to be a file instead of a directory
	else if (FALSE == isDir) {
		NSLog(@"%s.. document path is not a directory at '%@'", __PRETTY_FUNCTION__, mPath);
		return FALSE;
	}
	
	// create the source and destination paths for the database
	dbdst = [mPath stringByAppendingPathComponent:@"default.db"];
	dbsrc = [[NSBundle mainBundle] pathForResource:@"default" ofType:@"db"];
	
	// fail if the destination path for the database already exists
	if (TRUE == [fileManager fileExistsAtPath:dbdst]) {
		NSLog(@"%s.. the database file already exists for this document at '%@'", __PRETTY_FUNCTION__, dbdst);
		return FALSE;
	}
	
	// copy the default database from the application bundle to the document bundle
	if (FALSE == [fileManager copyItemAtPath:dbsrc toPath:dbdst error:&error]) {
		NSLog(@"%s.. failed to copy '%@' to '%@' because %@", __PRETTY_FUNCTION__, dbsrc, dbdst, [error localizedDescription]);
		return FALSE;
	}
	
	return TRUE;
}

/**
 * Attemps to connect to the database associated with this document (via the mPath member). The
 * database should be named "default.db". This'll throw an exception if the document is already 
 * connected to a database. And it'll fail (less forcefully) if the path is nil or invalid or any
 * one of a number of other things. After success, the database connection object is handed over to
 * the document for safe keeping.
 *
 */
- (BOOL)connectToDatabase
{
	DBConnection *dbconn = nil;
	
	// fail if the document is already connected to a database
	if (mDbConn != nil)
		@throw [NSException exceptionWithName:CZDBObjectAlreadyConnectedException reason:@"This document is already connected to a database." userInfo:nil];
	
	// fail if the path for this document is nil or zero-length
	if (0 == [mPath length]) {
		NSLog(@"%s.. no document path specified.", __PRETTY_FUNCTION__);
		return FALSE;
	}
	
	// create a new database connection object
	dbconn = [[SQLiteDBConnection alloc] initWithFileName:[mPath stringByAppendingPathComponent:@"default.db"]];
	
	// attempt to connect to the database
	if (FALSE == [dbconn connect]) {
		NSLog(@"%s.. failed to connect", __PRETTY_FUNCTION__);
		[dbconn release];
		return FALSE;
	}
	
	// assign the connected database connection object to the document
	self.dbconnection = dbconn;
	
	// we don't need the database connection here any longer
	[dbconn release];
	
	// tell the peepz that everything is good
	NSLog(@"%s.. connected to database in %@", __PRETTY_FUNCTION__, mPath);
	
	// yee-ha
	return TRUE;
}

/**
 * Attempts to disconnect from the database associated with this document and remove's the 
 * document's database connection object. This'll throw an exception if the document is not already
 * connected to a database. Throwing an exception in this case might be a bit over-kill, but we can
 * adjust this later if that turns out to be the case.
 *
 */
- (BOOL)disconnectFromDatabase
{
	// fail if the document is not already connected to a database
	if (mDbConn == nil)
		@throw [NSException exceptionWithName:CZDBObjectNoConnectionException reason:@"This document is not connected to a database." userInfo:nil];
	
	// attempt to disconnect from the database
	if (FALSE == [mDbConn disconnect]) {
		NSLog(@"%s.. failed to disconnect?!", __PRETTY_FUNCTION__);
		return FALSE;
	}
	
	// clear out the document's database connection object
	self.dbconnection = nil;
	
	// yee-ha
	return TRUE;
}





#pragma mark -
#pragma mark Groups

/**
 * Loads all of the groups found in this document's database into the groups array of the document.
 *
 */
- (BOOL)loadGroups
{
	NSArray *groups = [CZGroup dbobjectSelectAllForDocument:self];
	
	for (CZGroup *group in groups)
		[mGroups setObject:group forKey:[NSNumber numberWithInteger:group.groupId]];
	
	return TRUE;
}

/**
<<<<<<< .mine
 *
 *
 */
- (NSArray *)selectAllRootGroups
{
	NSMutableArray *groups = [NSMutableArray array];
	
	for (CZGroup *group in mGroups) {
		if (group.parentId == 0)
			[groups addObject:group];
	}
	
	return groups;
}

/**
 *
 *
 */
- (CZGroup *)addGroupWithName:(NSString *)name
{
	return [self addGroup:[CZGroup groupWithName:name] withParent:nil];
}

/**
 *
 *
 */
- (CZGroup *)addGroupWithName:(NSString *)name andParent:(CZGroup *)parent
{
	return [self addGroup:[CZGroup groupWithName:name] withParent:parent];
}

/**
 *
 *
 */
- (CZGroup *)addGroup:(CZGroup *)group
{
	return [self addGroup:group withParent:nil];
}

/**
 *
 *
 */
- (CZGroup *)addGroup:(CZGroup *)group withParent:(CZGroup *)parent
{
	// if the parent isn't nil, then the parent must have already been added to the database.
	if (parent != nil && parent.groupId == 0) {
		NSLog(@"%s.. can't insert group with non-database-backed parent", __PRETTY_FUNCTION__);
		return nil;
	}
	
	// tell the new group object which document and parent group it belongs to.
	group.document = self;
	group.parentId = parent.groupId;
	
	// try to insert the new group into the database
	if (FALSE == [group dbobjectInsert]) {
		NSLog(@"%s.. failed to insert new group with name, '%@'", __PRETTY_FUNCTION__, name);
		return nil;
	}
	
	// give the parent group its new child group
	[parent addChild:group];
	
	return group;
}

/**
 *
 *
 */
- (BOOL)removeGroup:(CZGroup *)group
{
	if (group.groupId == 0) {
		NSLog(@"%s.. can't remove group that is not database backed", __PRETTY_FUNCTION__);
		return FALSE;
	}
	
	if (FALSE == [group dbobjectDelete]) {
		NSLog(@"%s.. failed to delete group from database [id=%u, parent=%u, name=%@]", __PRETTY_FUNCTION__, group.groupId, group.parentId, group.name);
		return FALSE;
	}
	
	return TRUE;
}

/**
 *
 *
 */
- (BOOL)moveGroup:(CZGroup *)group toParent:(CZGroup *)parent
{
	CZGroup *oldParent = nil;
	
	// if the parent isn't nil, then the parent must have already been added to the database. if the
	// parent is nil, then this call is an attempt to move a group to the top-level.
	if (parent != nil && parent.groupId == 0) {
		NSLog(@"%s.. can't insert group with non-database-backed parent", __PRETTY_FUNCTION__);
		return FALSE;
	}
	
	// we do not allow groups to be re-parented until they're in the database
	if (group.groupId == 0) {
		NSLog(@"%s.. a group must be added to the database before it can be re-parented", __PRETTY_FUNCTION__);
		return FALSE;
	}
	
	// if the parent is nil then this is an attempt to move a group to the top-level; and if the group
	// is already a top-level group (ie, it has no parent), then we're already done.
	if (parent == nil && group.parentId == 0) {
		NSLog(@"%s.. this group is already a top-level group", __PRETTY_FUNCTION__);
		return TRUE;
	}
	
	// you can not set a group to be its own parent. really. don't try it.
	if (group.groupId == parent.groupId) {
		NSLog(@"%s.. you may not assign a group to be its own parent", __PRETTY_FUNCTION__);
		return FALSE;
	}
	
	// if the new parent group is already the parent of this group then we have nothing to do
	if (group.parentId == mParentId)
		return;
	
	// get the current parent and remove ourself from it as a child
	oldParent = [mDocument groupWithId:mParentId];
	[oldParent removeChild:self];
	
	// add ourself as a child to our new parent
	mParentId = group.groupId;
	[group addChild:self];
	
	// save our "adoption" change back to the database
	if (FALSE == [self save]) {
		NSLog(@"%s.. failed to re-parent group", __PRETTY_FUNCTION__);
		[oldParent addChild:self];
		[group removeChild:self];
	}
}

/**
 *
 *
 */
- (CZGroup *)groupWithId:(NSUInteger)groupId
{
	if (groupId == 0)
		return nil;
	
	return [mGroups objectForKey:[NSNumber numberWithInteger:groupId]];
}





#pragma mark -
#pragma mark Scripts

/**
=======
 *
 *
 */
- (NSArray *)selectAllRootItems
{
	BOOL retval = TRUE;
	DBConnection *connection;
	DBResult *result = nil;
	DBStatement *statement = nil;
	NSMutableArray *groupitems = [NSMutableArray array];
	
	// verify that we have a database connection
	if (nil == (connection = self.dbconnection))
		@throw [NSException exceptionWithName:CZDBObjectNoConnectionException reason:@"No connection associated with this document." userInfo:nil];
	
	// get the prepared statement for this operation
	if (nil == (statement = [connection statementForName:@"group_item_select_all_root_items"]))
		@throw [NSException exceptionWithName:CZDBObjectNoStatementException reason:@"Could not find the required statement" userInfo:nil];
	
	// execute statement
	if (![connection exec:statement result:&result])
		CZ_DBOBJ_ERROR(statement,retval,done);
	
	// handle result
	while (![result isDone]) {
		NSUInteger itemid = 0;
		NSString *type = nil;
		
		[result getUint32:&itemid atColumn:0];
		[result getString:&type atColumn:1];
		
		if ([type isEqual:@"GROUP"])
			[groupitems addObject:[self groupWithId:itemid]];
		else if ([type isEqual:@"SCRIPT"])
			[groupitems addObject:[self scriptWithId:itemid]];
//	else if ([type isEqual:@"MEDIA"])
//		;
		
		[result next];
	}
	
done:
	[statement clear];
	return groupitems;
}

/**
 *
 *
 */
- (CZGroup *)addGroupWithName:(NSString *)name
{
	return [self addGroup:[CZGroup groupWithName:name] withParent:nil];
}

/**
 *
 *
 */
- (CZGroup *)addGroupWithName:(NSString *)name andParent:(CZGroup *)parent
{
	return [self addGroup:[CZGroup groupWithName:name] withParent:parent];
}

/**
 *
 *
 */
- (CZGroup *)addGroup:(CZGroup *)group
{
	return [self addGroup:group withParent:nil];
}

/**
 *
 *
 */
- (CZGroup *)addGroup:(CZGroup *)group withParent:(CZGroup *)parent
{
	// if the parent isn't nil, then the parent must have already been added to the database.
	if (parent != nil && parent.groupId == 0) {
		NSLog(@"%s.. can't insert group with non-database-backed parent", __PRETTY_FUNCTION__);
		return nil;
	}
	
	// tell the new group object which document and parent group it belongs to.
	group.document = self;
	group.parentId = parent.groupId;
	
	// try to insert the new group into the database
	if (FALSE == [group dbobjectInsert]) {
		NSLog(@"%s.. failed to insert new group", __PRETTY_FUNCTION__);
		return nil;
	}
	
	// we retain a copy of each group object keyed on its id
	[mGroups setObject:group forKey:[NSNumber numberWithInteger:group.groupId]];
	
	return group;
}

/**
 *
 *
 */
- (BOOL)removeGroup:(CZGroup *)group
{
	if (group.groupId == 0) {
		NSLog(@"%s.. can't remove group that is not database backed", __PRETTY_FUNCTION__);
		return FALSE;
	}
	
	if (FALSE == [group dbobjectDelete]) {
		NSLog(@"%s.. failed to delete group from database [id=%u, parent=%u, name=%@]", __PRETTY_FUNCTION__, group.groupId, group.parentId, group.name);
		return FALSE;
	}
	
	return TRUE;
}

/**
 *
 *
 */
- (BOOL)moveGroup:(CZGroup *)group toParent:(CZGroup *)parent
{
	CZGroup *oldParent = nil;
	
	// if the parent isn't nil, then the parent must have already been added to the database. if the
	// parent is nil, then this call is an attempt to move a group to the top-level.
	if (parent != nil && parent.groupId == 0) {
		NSLog(@"%s.. can't insert group with non-database-backed parent", __PRETTY_FUNCTION__);
		return FALSE;
	}
	
	// we do not allow groups to be re-parented until they're in the database
	if (group.groupId == 0) {
		NSLog(@"%s.. a group must be added to the database before it can be re-parented", __PRETTY_FUNCTION__);
		return FALSE;
	}
	
	// if the parent is nil then this is an attempt to move a group to the top-level; and if the group
	// is already a top-level group (ie, it has no parent), then we're already done.
	if (parent == nil && group.parentId == 0) {
		NSLog(@"%s.. this group is already a top-level group", __PRETTY_FUNCTION__);
		return TRUE;
	}
	
	// you can not set a group to be its own parent. really. don't try it.
	if (group.groupId == parent.groupId) {
		NSLog(@"%s.. you may not assign a group to be its own parent", __PRETTY_FUNCTION__);
		return FALSE;
	}
	
	// if the new parent group is already the parent of this group then we have nothing to do
	if (group.parentId == parent.groupId)
		return FALSE;
	
	// get the current parent and remove ourself from it as a child
	oldParent = [self groupWithId:parent.groupId];
	
	// add the group as a child to the new parent
	group.parentId = parent.groupId;
	
	// save our "adoption" change back to the database
	if (FALSE == [group save]) {
		NSLog(@"%s.. failed to re-parent group", __PRETTY_FUNCTION__);
		return FALSE;
	}
	
	return TRUE;
}

/**
 *
 *
 */
- (BOOL)renameGroup:(CZGroup *)group withName:(NSString *)name
{
	NSString *oldName = nil;
	
	// the group must be added to the database before it can be re-named
	if (group.groupId == 0) {
		NSLog(@"%s.. you can not rename a group that hasn't yet been added to the database.", __PRETTY_FUNCTION__);
		return FALSE;
	}
	
	// when renaming a group, you must pick a new name
	if ([group.name isEqual:name]) {
		NSLog(@"%s.. you can not rename a group to its existing name.", __PRETTY_FUNCTION__);
		return FALSE;
	}
	
	// keep a copy of the old name so that we can restore it if save() fails
	oldName = [group.name retain];
	
	// try to save the group with its new name; restore its old name if save() fails
	if (FALSE == [group save]) {
		NSLog(@"%s.. failed to rename group to, %@", __PRETTY_FUNCTION__, name);
		group.name = oldName;
		[oldName release];
		return FALSE;
	}
	
	[oldName release];
	
	return TRUE;
}

/**
 *
 *
 */
- (CZGroup *)groupWithId:(NSUInteger)groupId
{
	if (groupId == 0)
		return nil;
	
	return [mGroups objectForKey:[NSNumber numberWithInteger:groupId]];
}





#pragma mark -
#pragma mark Scripts

/**
>>>>>>> .r898
 * Loads all of the scripts found in this document's database into the scripts array of the document.
 *
 */
- (BOOL)loadScripts
{
	for (CZScript *script in [CZScript dbobjectSelectAllForDocument:self]) {
		[self addScript:script];
	}
	
	return TRUE;
}

/**
 *
 *
 */
- (CZScript *)addScript:(CZScript *)script
{
	NSNumber *key = [NSNumber numberWithInteger:script.scriptId];
	
	if (script == nil) {
		NSLog(@"%s.. you can not add a null script", __PRETTY_FUNCTION__);
		return nil;
	}
	
	if (nil != [mScripts objectForKey:key]) {
		NSLog(@"%s.. you can not add a script with an identical key", __PRETTY_FUNCTION__);
		return nil;
	}
	
	[mScripts setObject:script forKey:key];
	
	return script;
}

/**
 *
 *
 */
- (CZScript *)scriptWithId:(NSUInteger)scriptId
{
	return [mScripts objectForKey:[NSNumber numberWithInteger:scriptId]];
}

@end
