//
//  CZSyncPoint+DBObject.m
//  ScriptSync
//
//  Created by Curtis Jones on 2010.10.08.
//  Copyright 2010 Nexidia, Inc. All rights reserved.
//

#import "CZSyncPoint+DBObject.h"
#import "CZTake+DBObject.h"
#import "CZScript+DBObject.h"
#import "CZSlate+DBObject.h"
#import "CZDocument+DBObject.h"
#import "CZElement.h"
#import "DBObject.h"
#import "DBConnection.h"
#import "DBResult.h"
#import "DBStatement.h"
#import "Easy.h"

@interface CZSyncPoint (DBObjectPrivate)
- (CZSyncPoint *)__dbobjectHandleResult:(DBResult *)result;
@end

@implementation CZSyncPoint (DBObject)

/**
 *
 *
 */
+ (NSArray *)dbobjectSelectAllForDocument:(CZDocument *)document
{
	BOOL retval = TRUE;
	DBConnection *connection = nil;
	DBResult *result = nil;
	DBStatement *statement = nil;
	CZSyncPoint *object = nil;
	NSMutableArray *objects = [NSMutableArray array];
	
	// from the script to the document to the db connection
	if (nil == (connection = document.dbconnection))
		@throw [NSException exceptionWithName:CZExceptionNoDbConnection reason:@"No connection associated with this script." userInfo:nil];
	
	// get the prepared statement for this operation
	if (nil == (statement = [connection statementForName:@"syncpoint_select_all"]))
		@throw [NSException exceptionWithName:CZExceptionNoStatement reason:@"Could not find the required statement" userInfo:nil];
	
	// execute statement
	if (![connection exec:statement result:&result])
		CZ_DBOBJ_ERROR(statement,retval,done);
	
	// give the document to the result object so that the handler can use it if it needs to
	result.document = document;
	
	// handle result
	CZ_DBOBJ_HANDLE([CZSyncPoint syncPoint], @selector(__addCachedSyncPoint:));
	
done:
	[statement clear];
	return objects;
}

/**
 *
 *
 */
- (BOOL)dbobjectInsert
{
	BOOL retval = TRUE;
	DBConnection *connection = nil;
	DBResult *result = nil;
	DBStatement *statement = nil;
	NSUInteger databaseId;	
	
	// from the take to the slate to the script to the document to the db connection
	if (nil == (connection = self.document.dbconnection))
		@throw [NSException exceptionWithName:CZExceptionNoDbConnection reason:@"No connection associated with this sync point." userInfo:nil];
	
	// get the prepared statement for this operation
	if (nil == (statement = [connection statementForName:@"syncpoint_insert"]))
		@throw [NSException exceptionWithName:CZExceptionNoStatement reason:@"Could not find the required statement" userInfo:nil];
	
	// if this object already has a database key then don't insert it again
	if (mDatabaseId != 0)
		@throw [NSException exceptionWithName:CZExceptionIllegalOperation reason:@"Can not insert an already inserted object" userInfo:nil];
	
	if (mTakeId == 0)
		mTakeId = mTake.databaseId;
	
	if (mElementId == 0)
		mElementId = mElement.databaseId;
	
	// setup
	{
		[statement bindUint32:mTakeId atIndex:1];
		[statement bindUint32:mElementId atIndex:2];
		[statement bindUint32:mDuration atIndex:3];
		[statement bindFloat:mScore atIndex:4];
		[statement bindUint32:mCharOffset atIndex:5];
		[statement bindUint32:mCentOffset atIndex:6];
		[statement bindUint32:mManual atIndex:7];
	}
	
	// execute statement
	if (![connection exec:statement result:&result])
		CZ_DBOBJ_ERROR(statement,retval,done);
	
	// get primary key
	if (TRUE == [connection lastInsertRowId:&databaseId]) {
		self.databaseId = databaseId;
		[self.document __addCachedSyncPoint:(CZSyncPoint *)[self dbobjectCopy]];
	}
	else
		NSLog(@"%s.. failed to lastInsertRowId()", __PRETTY_FUNCTION__);
	
done:
	[statement clear];
	return retval;
}

/**
 *
 *
 */
- (BOOL)dbobjectUpdate
{
	BOOL retval = TRUE;
	DBConnection *connection = nil;
	DBResult *result = nil;
	DBStatement *statement = nil;
	
	if ([[self.document __getCachedSyncPointForSyncPoint:self] dbobjectCompare:self] == DBObjectComparisonEquals)
		return TRUE;
	
	// from the take to the slate to the script to the document to the db connection
	if (nil == (connection = self.document.dbconnection))
		@throw [NSException exceptionWithName:CZExceptionNoDbConnection reason:@"No connection associated with this sync point." userInfo:nil];
	
	// get the prepared statement for this operation
	if (nil == (statement = [connection statementForName:@"syncpoint_update_by_id"]))
		@throw [NSException exceptionWithName:CZExceptionNoStatement reason:@"Could not find the required statement" userInfo:nil];
	
	// the record must already have been inserted before we can attempt to update it
	if (mDatabaseId == 0)
		@throw [NSException exceptionWithName:CZExceptionIllegalOperation reason:@"Can not update a record that hasn't yet been inserted" userInfo:nil];
	
	if (mTakeId == 0)
		mTakeId = mTake.databaseId;
	
	if (mElementId == 0)
		mElementId = mElement.databaseId;
	
	// setup
	{
		[statement bindUint32:mTakeId atIndex:1];
		[statement bindUint32:mElementId atIndex:2];
		[statement bindUint32:mDuration atIndex:3];
		[statement bindFloat:mScore atIndex:4];
		[statement bindUint32:mCharOffset atIndex:5];
		[statement bindUint32:mCentOffset atIndex:6];
		[statement bindUint32:mManual atIndex:7];
		[statement bindUint32:mDatabaseId atIndex:8];
	}
	
	// execute statement
	if (![connection exec:statement result:&result])
		CZ_DBOBJ_ERROR(statement,retval,done);
	
	[self.document __addCachedSyncPoint:(CZSyncPoint *)[self dbobjectCopy]];
	
done:
	[statement clear];
	return retval;
}

/**
 *
 *
 */
- (BOOL)dbobjectDelete
{
	BOOL retval = TRUE;
	DBConnection *connection = nil;
	DBResult *result = nil;
	DBStatement *statement = nil;
	
	// from the script to the document to the db connection
	if (nil == (connection = self.document.dbconnection))
		@throw [NSException exceptionWithName:CZExceptionNoDbConnection reason:@"No connection associated with this sync point." userInfo:nil];
	
	// get the prepared statement for this operation
	if (nil == (statement = [connection statementForName:@"syncpoint_delete_by_id"]))
		@throw [NSException exceptionWithName:CZExceptionNoStatement reason:@"Could not find the required statement" userInfo:nil];
	
	// the record must already have been inserted before we can attempt to delete it
	if (mDatabaseId == 0)
		@throw [NSException exceptionWithName:CZExceptionIllegalOperation reason:@"Can not delete a record that hasn't yet been inserted" userInfo:nil];
	
	// setup
	[statement bindUint32:mDatabaseId atIndex:1];
	
	// execute statement
	if (![connection exec:statement result:&result])
		CZ_DBOBJ_ERROR(statement,retval,done);
	
	[[self retain] autorelease];
	[self.document __removeSyncPoint:self];
	[self.document __removeCachedSyncPoint:self];
	
done:
	[statement clear];
	return retval;
}

/**
 *
 *
 */
- (DBObjectComparisonResult)dbobjectCompare:(id<DBObject>)anObject
{
	CZSyncPoint *point = (CZSyncPoint *)anObject;
	
	if (point->mCharOffset == mCharOffset &&
			point->mCentOffset == mCentOffset &&
			point->mDuration == mDuration &&
			point->mScore == mScore &&
			point->mManual == mManual &&
			point->mTakeId == mTakeId &&
			point->mElementId == mElementId)
		return DBObjectComparisonEquals;
	else
		return DBObjectComparisonNotEquals;
}

/**
 *
 *
 */
- (id<DBObject>)dbobjectCopy
{
	CZSyncPoint *point = [self copy];
	
	point->mCharOffset = mCharOffset;
	point->mCentOffset = mCentOffset;
	point->mDuration = mDuration;
	point->mScore = mScore;
	point->mManual = mManual;
	point->mTakeId = mTakeId;
	point->mElementId = mElementId; 
	
	return point;
}





#pragma mark -
#pragma mark Private

/**
 *
 *
 */
- (CZSyncPoint *)__dbobjectHandleResult:(DBResult *)result
{
	[result getUint32:&mDatabaseId atColumn:0];
	[result getUint32:&mTakeId atColumn:1];
	[result getUint32:&mElementId atColumn:2];
	[result getUint32:&mDuration atColumn:3];
	[result getFloat:&mScore atColumn:4];
	[result getUint32:&mCharOffset atColumn:5];
	[result getUint32:&mCentOffset atColumn:6];
	[result getUint32:&mManual atColumn:7];
	
	self.take = [result.document takeWithId:mTakeId];
	self.element = [result.document elementWithId:mElementId];
	
	return self;
}

@end
